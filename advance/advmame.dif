diff -U 5 --new-file --recursive src.ori/advance.pat src/advance.pat
--- src.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ src/advance.pat	2006-06-16 18:45:09.000000000 +0200
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive src.ori/config.c src/config.c
--- src.ori/config.c	2006-04-13 07:48:26.000000000 +0200
+++ src/config.c	2006-06-16 18:45:12.000000000 +0200
@@ -113,20 +113,27 @@
  *
  *  Settings save/load frontend
  *
  *************************************/
 
+int input_config_load_settings();
+void input_config_save_settings(void);
+
 int config_load_settings(void)
 {
 	config_type *type;
 	mame_file *file;
 	int loaded = 0;
 
 	/* loop over all registrants and call their init function */
 	for (type = typelist; type; type = type->next)
 		(*type->load)(CONFIG_TYPE_INIT, NULL);
 
+/* AdvanceMAME: Specific configuration for port */
+#if 1
+	loaded = input_config_load_settings();
+#else
 	/* now load the controller file */
 	if (options.controller != NULL)
 	{
 		/* open the config file */
 		file = mame_fopen(NULL, options.controller, FILETYPE_CTRLR, 0);
@@ -152,10 +159,11 @@
 	if (file)
 	{
 		loaded = config_load_xml(file, CONFIG_TYPE_GAME);
 		mame_fclose(file);
 	}
+#endif
 
 	/* loop over all registrants and call their final function */
 	for (type = typelist; type; type = type->next)
 		(*type->load)(CONFIG_TYPE_FINAL, NULL);
 
@@ -172,10 +180,14 @@
 
 	/* loop over all registrants and call their init function */
 	for (type = typelist; type; type = type->next)
 		(*type->save)(CONFIG_TYPE_INIT, NULL);
 
+/* AdvanceMAME: Specific configuration for port */
+#if 1
+	input_config_save_settings();
+#else
 	/* save the defaults file */
 	file = mame_fopen("default", 0, FILETYPE_CONFIG, 1);
 	if (file)
 	{
 		config_save_xml(file, CONFIG_TYPE_DEFAULT);
@@ -187,10 +199,11 @@
 	if (file)
 	{
 		config_save_xml(file, CONFIG_TYPE_GAME);
 		mame_fclose(file);
 	}
+#endif
 
 	/* loop over all registrants and call their final function */
 	for (type = typelist; type; type = type->next)
 		(*type->save)(CONFIG_TYPE_FINAL, NULL);
 }
diff -U 5 --new-file --recursive src.ori/cpu/cpu.mak src/cpu/cpu.mak
--- src.ori/cpu/cpu.mak	2006-04-09 22:49:08.000000000 +0200
+++ src/cpu/cpu.mak	2006-06-16 20:34:03.000000000 +0200
@@ -648,29 +648,29 @@
 OBJDIRS += $(OBJ)/cpu/m68000
 CPUOBJS += $(OBJ)/cpu/m68000/m68kcpu.o $(OBJ)/cpu/m68000/m68kmame.o $(subst .c,.o,$(M68000_GENERATED_FILES))
 DBGOBJS += $(OBJ)/cpu/m68000/m68kdasm.o
 
 # when we compile source files we need to include generated files from the OBJ directory
-$(OBJ)/cpu/m68000/%.o: src/cpu/m68000/%.c
-	@echo Compiling $<...
-	$(CC) $(CDEFS) $(CFLAGS) -I$(OBJ)/cpu/m68000 -c $< -o $@
+#$(OBJ)/cpu/m68000/%.o: src/cpu/m68000/%.c
+#	@echo Compiling $<...
+#	$(CC) $(CDEFS) $(CFLAGS) -I$(OBJ)/cpu/m68000 -c $< -o $@
 
 # when we compile generated files we need to include stuff from the src directory
-$(OBJ)/cpu/m68000/%.o: $(OBJ)/cpu/m68000/%.c
-	@echo Compiling $<...
-	$(CC) $(CDEFS) $(CFLAGS) -Isrc/cpu/m68000 -c $< -o $@
+#$(OBJ)/cpu/m68000/%.o: $(OBJ)/cpu/m68000/%.c
+#	@echo Compiling $<...
+#	$(CC) $(CDEFS) $(CFLAGS) -Isrc/cpu/m68000 -c $< -o $@
 
 # rule to generate the C files
-$(M68000_GENERATED_FILES) $(M68000_GENERATED_HEADERS): $(OBJ)/cpu/m68000/m68kmake$(EXE) m68k_in.c
-	@echo Generating M68K source files...
-	$(OBJ)/cpu/m68000/m68kmake$(EXE) $(OBJ)/cpu/m68000 src/cpu/m68000/m68k_in.c
+#$(M68000_GENERATED_FILES) $(M68000_GENERATED_HEADERS): $(OBJ)/cpu/m68000/m68kmake$(EXE) m68k_in.c
+#	@echo Generating M68K source files...
+#	$(OBJ)/cpu/m68000/m68kmake$(EXE) $(OBJ)/cpu/m68000 src/cpu/m68000/m68k_in.c
 
 # rule to build the generator
-$(OBJ)/cpu/m68000/m68kmake$(EXE): $(OBJ)/cpu/m68000/m68kmake.o $(OSDBGOBJS)
+#$(OBJ)/cpu/m68000/m68kmake$(EXE): $(OBJ)/cpu/m68000/m68kmake.o $(OSDBGOBJS)
 
 # rule to ensure we build the header before building the core CPU file
-$(OBJ)/cpu/m68000/m68kcpu.o: $(M68000_GENERATED_HEADERS)
+#$(OBJ)/cpu/m68000/m68kcpu.o: $(M68000_GENERATED_HEADERS)
 
 endif
 
 
 
diff -U 5 --new-file --recursive src.ori/cpuexec.c src/cpuexec.c
--- src.ori/cpuexec.c	2006-03-29 08:17:58.000000000 +0200
+++ src/cpuexec.c	2006-06-24 15:59:51.000000000 +0200
@@ -291,10 +291,13 @@
 	/* initialize the various timers (suspends all CPUs at startup) */
 	cpu_inittimers();
 	watchdog_counter = WATCHDOG_IS_INVALID;
 	watchdog_setup(TRUE);
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for disabled CPUs) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_DISABLE))
diff -U 5 --new-file --recursive src.ori/drivers/namcos11.c src/drivers/namcos11.c
--- src.ori/drivers/namcos11.c	2006-04-26 07:32:12.000000000 +0200
+++ src/drivers/namcos11.c	2006-06-16 18:45:12.000000000 +0200
@@ -834,11 +834,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 8, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type1 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/namcos12.c src/drivers/namcos12.c
--- src.ori/drivers/namcos12.c	2006-03-09 07:56:16.000000000 +0100
+++ src/drivers/namcos12.c	2006-06-16 18:45:12.000000000 +0200
@@ -1451,11 +1451,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/psikyo4.c src/drivers/psikyo4.c
--- src.ori/drivers/psikyo4.c	2006-04-26 07:32:12.000000000 +0200
+++ src/drivers/psikyo4.c	2006-06-16 18:45:12.000000000 +0200
@@ -463,11 +463,11 @@
 static MACHINE_DRIVER_START( ps4small )
 	/* basic machine hardware */
 	MDRV_IMPORT_FROM(ps4big)
 
 #if DUAL_SCREEN
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 30*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 30*8-1)
 #else
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 30*8-1)
 #endif
 MACHINE_DRIVER_END
 
diff -U 5 --new-file --recursive src.ori/drivers/stv.c src/drivers/stv.c
--- src.ori/drivers/stv.c	2006-04-06 22:13:06.000000000 +0200
+++ src/drivers/stv.c	2006-06-16 18:45:12.000000000 +0200
@@ -3049,11 +3049,11 @@
 	MDRV_NVRAM_HANDLER(stv) /* Actually 93c45 */
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT )
 	MDRV_SCREEN_SIZE(1024, 1024)
-	MDRV_VISIBLE_AREA(0*8, 703, 0*8, 512) // we need to use a resolution as high as the max size it can change to
+	MDRV_VISIBLE_AREA(0*8, 320-1, 0*8, 224-1)
 	MDRV_PALETTE_LENGTH(2048+(2048*2))//standard palette + extra memory for rgb brightness.
 	MDRV_GFXDECODE(gfxdecodeinfo)
 
 	MDRV_VIDEO_START(stv_vdp2)
 	MDRV_VIDEO_UPDATE(stv_vdp2)
diff -U 5 --new-file --recursive src.ori/drivers/zn.c src/drivers/zn.c
--- src.ori/drivers/zn.c	2006-05-04 22:23:18.000000000 +0200
+++ src/drivers/zn.c	2006-06-16 18:45:12.000000000 +0200
@@ -661,11 +661,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -703,11 +703,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -911,11 +911,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1349,11 +1349,11 @@
 	MDRV_NVRAM_HANDLER( coh1000ta )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1451,11 +1451,11 @@
 	MDRV_NVRAM_HANDLER( coh1000tb )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1640,11 +1640,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1853,11 +1853,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2098,11 +2098,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2438,11 +2438,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2608,11 +2608,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2692,11 +2692,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2960,11 +2960,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2996,11 +2996,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -3035,11 +3035,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/inptport.c src/inptport.c
--- src.ori/inptport.c	2006-03-23 07:34:02.000000000 +0100
+++ src/inptport.c	2006-06-16 20:06:19.000000000 +0200
@@ -882,11 +882,13 @@
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_FRAMESKIP_DEC,	"Frameskip Dec",		SEQ_DEF_1(KEYCODE_F8) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_FRAMESKIP_INC,	"Frameskip Inc",		SEQ_DEF_1(KEYCODE_F9) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_THROTTLE,		"Throttle",				SEQ_DEF_1(KEYCODE_F10) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_SHOW_FPS,		"Show FPS",				SEQ_DEF_5(KEYCODE_F11, CODE_NOT, KEYCODE_LCONTROL, CODE_NOT, KEYCODE_LSHIFT) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_SNAPSHOT,		"Save Snapshot",		SEQ_DEF_3(KEYCODE_F12, CODE_NOT, KEYCODE_LSHIFT) )
+#if 0 /* AdvanceMAME has its record code */
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_RECORD_MOVIE,	"Record Movie",			SEQ_DEF_2(KEYCODE_F12, KEYCODE_LSHIFT) )
+#endif
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_TOGGLE_CHEAT,	"Toggle Cheat",			SEQ_DEF_1(KEYCODE_F6) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_UP,				"UI Up",				SEQ_DEF_3(KEYCODE_UP, CODE_OR, JOYCODE_1_UP) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_DOWN,			"UI Down",				SEQ_DEF_3(KEYCODE_DOWN, CODE_OR, JOYCODE_1_DOWN) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_LEFT,			"UI Left",				SEQ_DEF_3(KEYCODE_LEFT, CODE_OR, JOYCODE_1_LEFT) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_RIGHT,			"UI Right",				SEQ_DEF_3(KEYCODE_RIGHT, CODE_OR, JOYCODE_1_RIGHT) )
@@ -941,10 +943,32 @@
 static input_port_default_entry default_ports[ARRAY_LENGTH(default_ports_builtin)];
 static input_port_default_entry default_ports_backup[ARRAY_LENGTH(default_ports_builtin)];
 static const int input_port_count = ARRAY_LENGTH(default_ports_builtin);
 static int default_ports_lookup[__ipt_max][MAX_PLAYERS];
 
+/* AdvanceMAME: Custom settings load */
+int input_config_load_settings()
+{
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load_default(default_ports_backup, default_ports);
+
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load(input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Report no setting loaded, always show the disclaimer */
+	return 0;
+}
+
+/* AdvanceMAME: Custom settings save */
+void input_config_save_settings(void)
+{
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save_default(default_ports_backup, default_ports);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save(input_ports_default, Machine->input_ports);
+}
 
 
 /*************************************
  *
  *  Function prototypes
@@ -1989,12 +2013,18 @@
  *************************************/
 
 int input_port_type_pressed(int type, int player)
 {
 	int defindex = default_ports_lookup[type][player];
-	if (defindex != -1)
-		return seq_pressed(&default_ports[defindex].defaultseq);
+	if (defindex != -1) {
+		int pressed = seq_pressed(&default_ports[defindex].defaultseq);
+
+		/* AdvanceMAME: Filter all the input ports */
+		pressed = osd_input_port_filter(pressed, type, player, SEQ_TYPE_STANDARD);
+
+		return pressed;
+	}
 
 	return 0;
 }
 
 
@@ -2005,10 +2035,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if pressed, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -2038,10 +2071,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if so, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, set a 3x delay and leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -2155,10 +2191,13 @@
 void input_port_vblank_start(void)
 {
 	int ui_visible = ui_is_setup_active() || ui_is_onscrd_active();
 	int portnum, bitnum;
 
+	/* AdvanceMAME: Never disable the input port. */
+	ui_visible = 0;
+
 profiler_mark(PROFILER_INPUT);
 
 	/* update the digital joysticks first */
 	update_digital_joysticks();
 
@@ -2190,11 +2229,16 @@
 
 				/* handle non-analog types, but only when the UI isn't visible */
 				if (port->type != IPT_VBLANK && !IS_ANALOG(port) && !ui_visible)
 				{
 					/* if the sequence for this port is currently pressed.... */
-					if (seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD)))
+					int pressed = seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD));
+
+					/* AdvanceMAME: Filter all the input ports */
+					pressed = osd_input_port_filter(pressed, port->type, port->player, SEQ_TYPE_STANDARD);
+
+					if (pressed)
 					{
 #ifdef MESS
 						/* (MESS-specific) check for disabled keyboard */
 						if (port->type == IPT_KEYBOARD && osd_keyboard_disabled())
 							continue;
@@ -2333,17 +2377,18 @@
 			{
 				info->previous = info->current;
 				info->current = 0;
 
 				/* read all the associated ports */
-				if (info->port[JOYDIR_UP] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)))
+				/* AdvanceMAME: Filter all the input ports */
+				if (info->port[JOYDIR_UP] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)), info->port[JOYDIR_UP]->type, info->port[JOYDIR_UP]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_UP_BIT;
-				if (info->port[JOYDIR_DOWN] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_DOWN] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)), info->port[JOYDIR_DOWN]->type, info->port[JOYDIR_DOWN]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_DOWN_BIT;
-				if (info->port[JOYDIR_LEFT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_LEFT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_LEFT]->type, info->port[JOYDIR_LEFT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_LEFT_BIT;
-				if (info->port[JOYDIR_RIGHT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_RIGHT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_RIGHT]->type, info->port[JOYDIR_RIGHT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_RIGHT_BIT;
 
 				/* lock out opposing directions (left + right or up + down) */
 				if ((info->current & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) == (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT))
 					info->current &= ~(JOYDIR_UP_BIT | JOYDIR_DOWN_BIT);
@@ -2454,12 +2499,12 @@
 		int analog_type, keypressed = 0;
 
 		/* clamp the previous value to the min/max range and remember it */
 		info->previous = info->accum = apply_analog_min_max(info, info->accum);
 
-		/* get the new raw analog value and its type */
-		rawvalue = seq_analog_value(input_port_seq(port, SEQ_TYPE_STANDARD), &analog_type);
+		/* AdvanceMAME: Get the analog input for different players from the osd core. */
+		rawvalue = osd_get_analog_value(port->type, port->player, &analog_type);
 
 		/* if we got it from a relative device, use that as the starting delta */
 		/* also note that the last input was not a digital one */
 		if (analog_type == ANALOG_TYPE_RELATIVE && rawvalue != 0)
 		{
@@ -2467,18 +2512,20 @@
 			info->lastdigital = 0;
 		}
 
 		/* if the decrement code sequence is pressed, add the key delta to */
 		/* the accumulated delta; also note that the last input was a digital one */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)), info->port->type, info->port->player, SEQ_TYPE_DECREMENT))
 		{
 			delta -= (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
 		/* same for the increment code sequence */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)), info->port->type, info->port->player, SEQ_TYPE_INCREMENT))
 		{
 			delta += (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
@@ -2492,15 +2539,18 @@
 		info->accum += delta;
 
 		/* if we got an absolute input, it overrides everything else */
 		if (analog_type == ANALOG_TYPE_ABSOLUTE)
 		{
-			/* apply the inverse of the sensitivity to the raw value so that */
-			/* it will still cover the full min->max range requested after */
-			/* we apply the sensitivity adjustment */
-			info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
-			info->lastdigital = 0;
+			/* allow both the analog joystick and the keyboard to control the input port */
+			if (rawvalue != 0 || !info->lastdigital) {
+				/* apply the inverse of the sensitivity to the raw value so that */
+				/* it will still cover the full min->max range requested after */
+				/* we apply the sensitivity adjustment */
+				info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
+				info->lastdigital = 0;
+			}
 		}
 
 		/* if our last movement was due to a digital input, and if this control */
 		/* type autocenters, and if neither the increment nor the decrement seq */
 		/* was pressed, apply autocentering */
diff -U 5 --new-file --recursive src.ori/input.c src/input.c
--- src.ori/input.c	2006-03-21 12:02:34.000000000 +0100
+++ src/input.c	2006-06-16 18:47:39.000000000 +0200
@@ -514,10 +514,40 @@
 static int record_count;						/* number of key/joy press recorded */
 static clock_t record_last;						/* time of last key/joy press */
 static UINT8 record_analog;						/* are we recording an analog sequence? */
 
 
+/*************************************
+ *
+ *  OS helper
+ *
+ *************************************/
+
+os_code code_to_oscode(input_code code)
+{
+	if (code_map[code].osinfo != NULL)
+		return code_map[code].osinfo->oscode;
+	else
+		return 0;
+}
+
+input_code oscode_to_code(os_code oscode)
+{
+	unsigned i;
+
+	for(i=0;i<code_count;++i) {
+		if (code_map[i].osinfo != NULL && code_map[i].osinfo->oscode == oscode) {
+			break;
+		}
+	}
+
+	if (i == code_count)
+		return CODE_NONE;
+
+	return i;
+}
+
 
 /*************************************
  *
  *  Code table creation
  *
diff -U 5 --new-file --recursive src.ori/input.h src/input.h
--- src.ori/input.h	2006-02-26 21:12:26.000000000 +0100
+++ src/input.h	2006-06-16 19:27:04.000000000 +0200
@@ -13,10 +13,11 @@
 
 #ifndef __INPUT_H__
 #define __INPUT_H__
 
 #include "mamecore.h"
+#include "osdepend.h"
 
 
 /*************************************
  *
  *  Constants
@@ -485,10 +486,17 @@
 	CODE_NOT,					/* operators for sequences */
 	CODE_OR						/* operators for sequences */
 };
 
 
+/* AdvanceMAME: Remap the F1 key used by some debug code to an unused key. */
+#ifdef MESS
+#define KEYCODE_F1_REAL KEYCODE_F1
+#else
+#define KEYCODE_F1_REAL (KEYCODE_F2-1)
+#define KEYCODE_F1 KEYCODE_NUMLOCK
+#endif
 
 /*************************************
  *
  *  Type definitions
  *
@@ -526,10 +534,12 @@
  *************************************/
 
 /* single code functions */
 int code_init(void);
 
+os_code code_to_oscode(input_code code);
+input_code oscode_to_code(os_code oscode);
 INT32 code_analog_value(input_code code);
 int code_pressed(input_code code);
 int code_pressed_memory(input_code code);
 int code_pressed_memory_repeat(input_code code, int speed);
 input_code code_read_async(void);
diff -U 5 --new-file --recursive src.ori/mame.c src/mame.c
--- src.ori/mame.c	2006-05-03 22:45:00.000000000 +0200
+++ src/mame.c	2006-06-16 20:07:33.000000000 +0200
@@ -266,13 +266,16 @@
 	int error = 0;
 
 	/* start in the "pre-init phase" */
 	current_phase = MAME_PHASE_PREINIT;
 
+/* AdvanceMAME: Disable validity checks */
+#if 0
 	/* perform validity checks before anything else */
 	if (mame_validitychecks(game) != 0)
 		return 1;
+#endif
 
 	/* loop across multiple hard resets */
 	exit_pending = FALSE;
 	while (error == 0 && !exit_pending)
 	{
@@ -874,10 +877,23 @@
 		for (cb = logerror_callback_list; cb; cb = cb->next)
 			cb->func.log(giant_string_buffer);
 
 		profiler_mark(PROFILER_END);
 	}
+
+	/* AdvanceMAME: Internal logging */
+	{
+		va_list arg;
+
+		profiler_mark(PROFILER_LOGERROR);
+
+		va_start(arg, text);
+		osd_log_va(text, arg);
+		va_end(arg);
+
+		profiler_mark(PROFILER_END);
+	}
 }
 
 
 /*-------------------------------------------------
     add_logerror_callback - adds a callback to be
diff -U 5 --new-file --recursive src.ori/mamecore.h src/mamecore.h
--- src.ori/mamecore.h	2006-04-09 22:49:08.000000000 +0200
+++ src/mamecore.h	2006-06-16 20:11:00.000000000 +0200
@@ -97,11 +97,18 @@
 {
 	int min_x,max_x;
 	int min_y,max_y;
 };
 
-
+typedef struct _ui_menu_item ui_menu_item;
+struct _ui_menu_item
+{
+   const char *text;
+   const char *subtext;
+   UINT32 flags;
+   void *ref;
+};
 
 /***************************************************************************
  * Union of UINT8, UINT16 and UINT32 in native endianess of the target
  * This is used to access bytes and words in a machine independent manner.
  * The upper bytes h2 and h3 normally contain zero (16 bit CPU cores)
@@ -366,12 +373,14 @@
 
 /* since strdup is not part of the standard, we use this instead */
 char *mame_strdup(const char *str);
 
 /* this macro prevents people from using strdup directly */
+#if 0 /* AdvanceMAME: Allow the stddup use */
 #undef strdup
 #define strdup !MUST_USE_MAME_STRDUP_INSTEAD!
+#endif
 
 
 /* compute the intersection of two rectangles */
 INLINE void sect_rect(rectangle *dst, const rectangle *src)
 {
diff -U 5 --new-file --recursive src.ori/osdepend.h src/osdepend.h
--- src.ori/osdepend.h	2006-03-28 10:37:32.000000000 +0200
+++ src/osdepend.h	2006-06-16 20:08:32.000000000 +0200
@@ -334,11 +334,50 @@
 int osd_display_loading_rom_message(const char *name,rom_load_data *romdata);
 
 /* checks to see if a pointer is bad */
 int osd_is_bad_read_ptr(const void *ptr, size_t size);
 
+/* AdvanceMAME: Specific OSD interface */
 
+/* return the analog value of the specified input. */
+INT32 osd_get_analog_value(unsigned type, unsigned player, int* analog_type);
+
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(unsigned menu, int sel);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, unsigned type, unsigned player, int seqtype);
+
+/* snapshot saving */
+void osd_save_snapshot(void);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+void osd_ui_menu(const ui_menu_item *items, int numitems, int selected);
+void osd_ui_message(const char* text, int second);
+void osd_ui_osd(const char *text, int percentage, int default_percentage);
+void osd_ui_scroll(const char* text, int* pos);
+
+/* customize the inputport */
+void osd_config_load_default(input_port_default_entry* backup, input_port_default_entry* list);
+void osd_config_load(input_port_entry* backup, input_port_entry* list);
+void osd_config_save_default(input_port_default_entry* backup, input_port_default_entry* list);
+void osd_config_save(input_port_entry* backup, input_port_entry* list);
+
+/* handle the specific user interface */
+int osd_handle_user_interface(mame_bitmap *bitmap, int is_menu_active);
+
+/* osd logging */
+void osd_log_va(const char* text, va_list arg);
 
 #ifdef MESS
 /* this is here to follow the current mame file hierarchy style */
 #include "osd_mess.h"
 #endif
diff -U 5 --new-file --recursive src.ori/romload.c src/romload.c
--- src.ori/romload.c	2006-05-04 09:19:00.000000000 +0200
+++ src/romload.c	2006-06-16 19:07:01.000000000 +0200
@@ -1,5 +1,6 @@
+
 /*********************************************************************
 
     romload.c
 
     ROM loading functions.
@@ -389,11 +390,12 @@
 
 	/* if we had warnings, output them, but continue */
 	if (romdata->warnings)
 	{
 		strcat(romdata->errorbuf, "WARNING: the game might not run correctly.");
-		printf("%s\n", romdata->errorbuf);
+		/* AdvanceMAME: Display the message in the ui */
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 	}
 
 	/* clean up any regions */
 	if (romdata->errors)
 		for (region = 0; region < MAX_MEMORY_REGIONS; region++)
diff -U 5 --new-file --recursive src.ori/sound/sound.mak src/sound/sound.mak
--- src.ori/sound/sound.mak	2006-04-22 15:57:14.000000000 +0200
+++ src/sound/sound.mak	2006-06-16 18:45:12.000000000 +0200
@@ -62,13 +62,13 @@
 
 SOUNDDEFS += -DHAS_DISCRETE=$(if $(filter DISCRETE,$(SOUNDS)),1,0)
 
 ifneq ($(filter DISCRETE,$(SOUNDS)),)
 SOUNDOBJS += $(OBJ)/sound/discrete.o
-$(OBJ)/sound/discrete.o: src/sound/discrete.c src/sound/discrete.h \
-		src/sound/disc_dev.c src/sound/disc_flt.c src/sound/disc_inp.c \
-		src/sound/disc_mth.c src/sound/disc_wav.c
+$(OBJ)/sound/discrete.o: discrete.c discrete.h \
+		disc_dev.c disc_flt.c disc_inp.c \
+		disc_mth.c disc_wav.c
 endif
 
 
 
 #-------------------------------------------------
diff -U 5 --new-file --recursive src.ori/ui_text.c src/ui_text.c
--- src.ori/ui_text.c	2006-04-19 19:54:12.000000000 +0200
+++ src/ui_text.c	2006-06-16 18:45:12.000000000 +0200
@@ -86,11 +86,11 @@
 	"Dip Switches",
 	"Analog Controls",
 	"Calibrate Joysticks",
 	"Bookkeeping Info",
 
-	"Input (this " CAPSTARTGAMENOUN")",
+	"Input (this " GAMENOUN")",
 	CAPSTARTGAMENOUN " Information",
 	CAPSTARTGAMENOUN " History",
 	"Reset " CAPSTARTGAMENOUN,
 	"Return to " CAPSTARTGAMENOUN,
 
@@ -197,10 +197,14 @@
 
 	/* refresh rate */
 	"Refresh rate",
 	"Decoding Graphics",
 
+	/* AdvanceMAME: Extra user interface commands */
+	"Video",
+	"Audio",
+
 	NULL
 };
 
 
 
diff -U 5 --new-file --recursive src.ori/ui_text.h src/ui_text.h
--- src.ori/ui_text.h	2006-02-26 21:12:26.000000000 +0100
+++ src/ui_text.h	2006-06-16 18:45:12.000000000 +0200
@@ -193,10 +193,14 @@
 
 	/* refresh rate */
 	UI_refresh_rate,
 	UI_decoding_gfx,
 
+	/* AdvanceMAME: Extra user interface commands */
+	UI_osd_1,
+	UI_osd_2,
+
 	UI_last_mame_entry
 };
 
 #ifdef MESS
 #include "mui_text.h"
diff -U 5 --new-file --recursive src.ori/usrintrf.c src/usrintrf.c
--- src.ori/usrintrf.c	2006-05-04 09:19:00.000000000 +0200
+++ src/usrintrf.c	2006-06-16 20:09:11.000000000 +0200
@@ -690,13 +690,17 @@
  *
  *************************************/
 
 void ui_draw_text(const char *buf, int x, int y)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	logerror("ERROR:mame:invalid UI call ui_draw_text(%s,%d,%d)\n", buf, x, y);
+#else
 	int ui_width, ui_height;
 	ui_get_bounds(&ui_width, &ui_height);
 	ui_draw_text_full(buf, x, y, ui_width - x, JUSTIFY_LEFT, WRAP_WORD, DRAW_OPAQUE, RGB_WHITE, RGB_BLACK, NULL, NULL);
+#endif
 }
 
 
 
 /*************************************
@@ -705,10 +709,13 @@
  *
  *************************************/
 
 void ui_draw_text_full(const char *s, int x, int y, int wrapwidth, int justify, int wrap, int draw, rgb_t fgcolor, rgb_t bgcolor, int *totalwidth, int *totalheight)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	logerror("ERROR:mame:invalid UI call ui_draw_text_full(%s,%d,%d)\n", s, x, y);
+#else
 	const char *linestart;
 	int cury = y;
 	int maxwidth = 0;
 
 	/* if we don't want wrapping, guarantee a huge wrapwidth */
@@ -842,10 +849,11 @@
 	/* report the width and height of the resulting space */
 	if (totalwidth)
 		*totalwidth = maxwidth;
 	if (totalheight)
 		*totalheight = cury - y;
+#endif
 }
 
 
 
 /*************************************
@@ -854,10 +862,13 @@
  *
  *************************************/
 
 void ui_draw_menu(const ui_menu_item *items, int numitems, int selected)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_menu(items, numitems, selected);
+#else
 	const char *up_arrow = ui_getstring(UI_uparrow);
 	const char *down_arrow = ui_getstring(UI_downarrow);
 	const char *left_arrow = ui_getstring(UI_leftarrow);
 	const char *right_arrow = ui_getstring(UI_rightarrow);
 	const char *left_hilight = ui_getstring(UI_lefthilight);
@@ -1026,10 +1037,11 @@
 						target_x + target_width - 1 + UI_BOX_LR_BORDER,
 						target_y + target_height - 1 + UI_BOX_TB_BORDER);
 		ui_draw_text_full(item->subtext, target_x, target_y, target_width,
 					JUSTIFY_RIGHT, WRAP_WORD, DRAW_NORMAL, RGB_WHITE, RGB_BLACK, NULL, NULL);
 	}
+#endif
 }
 
 
 
 /*************************************
@@ -1125,10 +1137,13 @@
  *
  *************************************/
 
 static void draw_multiline_text_box(const char *text, int justify, float xpos, float ypos)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	logerror("ERROR:mame:invalid UI call ui_draw_multiline_text_box(%s)\n", text);
+#else
 	int target_width, target_height;
 	int ui_width, ui_height;
 	int target_x, target_y;
 
 	/* start with the bounds */
@@ -1159,16 +1174,21 @@
 					target_y - UI_BOX_TB_BORDER,
 					target_x + target_width - 1 + UI_BOX_LR_BORDER,
 					target_y + target_height - 1 + UI_BOX_TB_BORDER);
 	ui_draw_text_full(text, target_x, target_y, target_width,
 				justify, WRAP_WORD, DRAW_NORMAL, RGB_WHITE, RGB_BLACK, NULL, NULL);
+#endif
 }
 
 
 void ui_draw_message_window(const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(text, 0);
+#else
 	draw_multiline_text_box(text, JUSTIFY_LEFT, 0.5, 0.5);
+#endif
 }
 
 
 
 /*************************************
@@ -1254,10 +1274,14 @@
  *
  *************************************/
 
 static void handle_keys(mame_bitmap *bitmap)
 {
+	/* AdvanceMAME: Intercept user interface handling */
+	if (osd_handle_user_interface(bitmap, menu_handler != NULL) != 0)
+		mame_schedule_exit();
+
 #ifdef MESS
 	if (options.disable_normal_ui || ((Machine->gamedrv->flags & GAME_COMPUTER) && !mess_ui_active()))
 		return;
 #endif
 
@@ -1327,21 +1351,25 @@
 		}
 		else
 			mame_pause(!mame_is_paused());
 	}
 
+#if 0 /* AdvanceMAME has its record code */
 	/* toggle movie recording */
 	if (input_ui_pressed(IPT_UI_RECORD_MOVIE))
 		record_movie_toggle();
+#endif
 
 	/* toggle profiler display */
 	if (input_ui_pressed(IPT_UI_SHOW_PROFILER))
 		ui_set_show_profiler(!ui_get_show_profiler());
 
+#if 0 /* AdvanceMAME: The show_fps action is managed by the osd code */
 	/* toggle FPS display */
 	if (input_ui_pressed(IPT_UI_SHOW_FPS))
 		ui_set_show_fps(!ui_get_show_fps());
+#endif
 
 	/* toggle crosshair display */
 	if (input_ui_pressed(IPT_UI_TOGGLE_CROSSHAIR))
 		drawgfx_toggle_crosshair();
 }
@@ -1352,10 +1380,27 @@
  *
  *  Main menu
  *
  *************************************/
 
+static UINT32 menu_osd_1(UINT32 state)
+{
+	int result = osd_menu(0, state);
+	if (result == 0)
+		return ui_menu_stack_pop();
+	return result;
+
+}
+
+static UINT32 menu_osd_2(UINT32 state)
+{
+	int result = osd_menu(1, state);
+	if (result == 0)
+		return ui_menu_stack_pop();
+	return result;
+}
+
 static UINT32 menu_main(UINT32 state)
 {
 #define ADD_MENU(name, handler, param) \
 do { \
 	item_list[menu_items].text = ui_getstring(name); \
@@ -1445,10 +1490,14 @@
 
 	/* add memory card menu */
 	if (Machine->drv->memcard_handler != NULL)
 		ADD_MENU(UI_memorycard, menu_memory_card, 0);
 
+	/* AdvanceMAME: Extra menu UI_OSD */
+	ADD_MENU(UI_osd_1, menu_osd_1, 0);
+	ADD_MENU(UI_osd_2, menu_osd_2, 0);
+
 	/* add reset and exit menus */
 	ADD_MENU(UI_resetgame, menu_reset_game, 0);
 	ADD_MENU(UI_returntogame, NULL, 0);
 
 	/* draw the menu */
@@ -1606,10 +1655,11 @@
 			}
 
 			/* if we are analog, add three items */
 			else
 			{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 				if (menu_items == selected)
 				{
 					selected_seq = &in->defaultseq;
 					selected_defseq = &indef->defaultseq;
 					selected_is_analog = TRUE;
@@ -1627,10 +1677,11 @@
 				{
 					selected_seq = &in->defaultincseq;
 					selected_defseq = &indef->defaultincseq;
 				}
 				default_input_menu_add_item(&item_list[menu_items++], "%s Inc", in->name, &in->defaultincseq, &indef->defaultincseq);
+#endif
 			}
 		}
 
 	/* if we're polling, just put an empty entry and arrows for the subitem */
 	if (polling)
@@ -3269,13 +3320,15 @@
 		{
 			int ui_width, ui_height;
 
 			erase_screen(bitmap);
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 			ui_get_bounds(&ui_width, &ui_height);
 			add_filled_box(0, 0, ui_width - 1, ui_height - 1);
 			ui_draw_message_window(buf);
+#endif
 			render_ui(bitmap);
 
 			update_video_and_audio();
 			if (input_ui_pressed(IPT_UI_CANCEL))
 				return 1;
@@ -3303,13 +3356,15 @@
 
 	while (code_read_async() == CODE_NONE && !mame_is_scheduled_event_pending())
 	{
 		char *bufptr = buf;
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 		/* first draw a box around the whole screen */
 		ui_get_bounds(&ui_width, &ui_height);
 		add_filled_box(0, 0, ui_width - 1, ui_height - 1);
+#endif
 
 		/* add the game info */
 		bufptr += sprintf_game_info(bufptr);
 
 		/* append MAME version and ask for any key */
@@ -3337,13 +3392,15 @@
 
 	while (code_read_async() == CODE_NONE && !mame_is_scheduled_event_pending())
 	{
 		char *bufptr = buf;
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 		/* first draw a box around the whole screen */
 		ui_get_bounds(&ui_width, &ui_height);
 		add_filled_box(0, 0, ui_width - 1, ui_height - 1);
+#endif
 
 		/* add the game info */
 		bufptr += ui_sprintf_image_info(bufptr);
 
 		/* draw the window */
@@ -3380,10 +3437,11 @@
 
 /*-------------------------------------------------
     drawbar - draw a thermometer bar
 -------------------------------------------------*/
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 static void drawbar(int leftx, int topy, int width, int height, int percentage, int default_percentage)
 {
 	int current_x, default_x;
 	int bar_top, bar_bottom;
 
@@ -3402,15 +3460,19 @@
 	add_line(default_x, bar_bottom, default_x, topy + height - 1, RGB_WHITE);
 
 	/* fill in the percentage */
 	add_fill(leftx, bar_top + 1, current_x, bar_bottom - 1, RGB_WHITE);
 }
+#endif
 
 
 
 static void displayosd(const char *text,int percentage,int default_percentage)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_osd(text, percentage, default_percentage);
+#else
 	int space_width = ui_get_char_width(' ');
 	int line_height = ui_get_line_height();
 	int ui_width, ui_height;
 	int text_height;
 
@@ -3436,10 +3498,11 @@
 			ui_width - 2 * space_width, line_height*3/4, percentage, default_percentage);
 
 	/* draw the actual text */
 	ui_draw_text_full(text, space_width + UI_BOX_LR_BORDER, line_height + ui_height - UI_BOX_TB_BORDER - text_height, ui_width - 2 * UI_BOX_LR_BORDER,
 				JUSTIFY_CENTER, WRAP_WORD, DRAW_NORMAL, RGB_WHITE, RGB_BLACK, NULL, &text_height);
+#endif
 }
 
 static void onscrd_adjuster(int increment,int arg)
 {
 	input_port_entry *in = &Machine->input_ports[arg];
@@ -3469,17 +3532,17 @@
 	if (increment)
 	{
 		attenuation = osd_get_mastervolume();
 		attenuation += increment;
 		if (attenuation > 0) attenuation = 0;
-		if (attenuation < -32) attenuation = -32;
+		if (attenuation < -40) attenuation = -40;
 		osd_set_mastervolume(attenuation);
 	}
 	attenuation = osd_get_mastervolume();
 
 	sprintf(buf,"%s %3ddB", ui_getstring (UI_volume), attenuation);
-	displayosd(buf,100 * (attenuation + 32) / 32,100);
+	displayosd(buf,100 * (attenuation + 40) / 40,100);
 }
 
 static void onscrd_mixervol(int increment,int arg)
 {
 	static void *driver = 0;
@@ -3890,10 +3953,11 @@
 }
 
 
 void ui_display_fps(void)
 {
+#if 0 /* AdvanceMAME: Use custom ui code */
 	int ui_width, ui_height;
 
 	/* if we're not currently displaying, skip it */
 	if (!showfps && !showfpstemp)
 		return;
@@ -3909,30 +3973,36 @@
 	{
 		showfpstemp--;
 		if (!showfps && showfpstemp == 0)
 			schedule_full_refresh();
 	}
+#endif
 }
 
 static void ui_display_profiler(void)
 {
+#if 0 /* AdvanceMAME: Use custom ui code */
 	int ui_width, ui_height;
 
 	if (show_profiler)
 	{
 		ui_get_bounds(&ui_width, &ui_height);
 		ui_draw_text_full(profiler_get_text(), 0, 0, ui_width, JUSTIFY_LEFT, WRAP_WORD, DRAW_OPAQUE, RGB_WHITE, RGB_BLACK, NULL, NULL);
 	}
+#endif
 }
 
 static void ui_display_popup(void)
 {
 	/* show popup message if any */
 	if (popup_text_counter > 0)
 	{
+#if 1 /* AdvanceMAME: Use custom ui code */
+		osd_ui_scroll(popup_text, 0);
+#else
 		draw_multiline_text_box(popup_text, JUSTIFY_CENTER, 0.5f, 0.9f);
-
+#endif
 		if (--popup_text_counter == 0)
 			schedule_full_refresh();
 	}
 }
 
@@ -4009,10 +4079,11 @@
 		rect->max_y = temp;
 	}
 }
 
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 static void add_line(int x1, int y1, int x2, int y2, rgb_t color)
 {
 	if (elemindex < ARRAY_LENGTH(elemlist))
 	{
 		elemlist[elemindex].x = (x1 < x2) ? x1 : x2;
@@ -4052,14 +4123,20 @@
 	add_line(x1, y1, x2, y1, RGB_WHITE);
 	add_line(x2, y1, x2, y2, RGB_WHITE);
 	add_line(x2, y2, x1, y2, RGB_WHITE);
 	add_line(x1, y2, x1, y1, RGB_WHITE);
 }
+#endif
 
 
 static void render_ui(mame_bitmap *dest)
 {
+/* AdvanceMAME: Custom ui */
+	if (elemindex != 0) {
+		logerror("Invalid UI access, %d", elemindex);
+	}
+#if 0
 	int i;
 
 	uirotfont->colortable[0] = get_black_pen();
 	uirotfont->colortable[1] = get_white_pen();
 	uirotfont->colortable[2] = get_white_pen();
@@ -4095,6 +4172,7 @@
 				break;
 		}
 	}
 
 	elemindex = 0;
+#endif
 }
diff -U 5 --new-file --recursive src.ori/usrintrf.h src/usrintrf.h
--- src.ori/usrintrf.h	2006-03-22 08:42:18.000000000 +0100
+++ src/usrintrf.h	2006-06-16 18:54:19.000000000 +0200
@@ -68,20 +68,10 @@
  *
  *************************************/
 
 typedef UINT32 (*ui_menu_handler)(UINT32 state);
 
-typedef struct _ui_menu_item ui_menu_item;
-struct _ui_menu_item
-{
-   const char *text;
-   const char *subtext;
-   UINT32 flags;
-   void *ref;
-};
-
-
 
 /*************************************
  *
  *  Global variables
  *
diff -U 5 --new-file --recursive src.ori/video.c src/video.c
--- src.ori/video.c	2006-05-10 21:35:28.000000000 +0200
+++ src/video.c	2006-06-16 19:04:49.000000000 +0200
@@ -854,10 +854,11 @@
 /*-------------------------------------------------
     save_frame_with - save a frame with a
     given handler for screenshots and movies
 -------------------------------------------------*/
 
+#if 0 /* AdvanceMAME has its snapshot code */
 static void save_frame_with(mame_file *fp, mame_bitmap *bitmap, int (*write_handler)(mame_file *, mame_bitmap *))
 {
 	rectangle bounds;
 	mame_bitmap *osdcopy;
 	UINT32 saved_rgb_components[3];
@@ -957,20 +958,23 @@
 
 	/* if the OSD system allocated a bitmap; free it */
 	if (osdcopy)
 		bitmap_free(osdcopy);
 }
+#endif
 
 
  /*-------------------------------------------------
     save_screen_snapshot_as - save a snapshot to
     the given file handle
 -------------------------------------------------*/
 
 void save_screen_snapshot_as(mame_file *fp, mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its snapshot code */
 	save_frame_with(fp, bitmap, png_write_bitmap);
+#endif
 }
 
 
 /*-------------------------------------------------
     open the next non-existing file of type
@@ -1003,52 +1007,61 @@
     save_screen_snapshot - save a snapshot.
 -------------------------------------------------*/
 
 void save_screen_snapshot(mame_bitmap *bitmap)
 {
+#if 1 /* AdvanceMAME has its snapshot code */
+	osd_save_snapshot();
+#else
 	mame_file *fp;
 
 	if ((fp = mame_fopen_next(FILETYPE_SCREENSHOT)) != NULL)
 	{
 		save_screen_snapshot_as(fp, bitmap);
 		mame_fclose(fp);
 	}
+#endif
 }
 
 
 /*-------------------------------------------------
     record_movie - start, stop and update the
     recording of a MNG movie
 -------------------------------------------------*/
 
 void record_movie_start(const char *name)
 {
+#if 0 /* AdvanceMAME has its record code */
 	if (movie_file != NULL)
 		mame_fclose(movie_file);
 
 	if (name)
 		movie_file = mame_fopen(Machine->gamedrv->name, name, FILETYPE_MOVIE, 1);
 	else
 		movie_file = mame_fopen_next(FILETYPE_MOVIE);
 
 	movie_frame = 0;
+#endif
 }
 
 
 void record_movie_stop(void)
 {
+#if 0 /* AdvanceMAME has its record code */
 	if (movie_file)
 	{
 		mng_capture_stop(movie_file);
 		mame_fclose(movie_file);
 		movie_file = NULL;
 	}
+#endif
 }
 
 
 void record_movie_toggle(void)
 {
+#if 0 /* AdvanceMAME has its record code */
 	if (movie_file == NULL)
 	{
 		record_movie_start(NULL);
 		if (movie_file)
 			ui_popup("REC START");
@@ -1056,25 +1069,28 @@
 	else
 	{
 		record_movie_stop();
 		ui_popup("REC STOP (%d frames)", movie_frame);
 	}
+#endif
 }
 
 
 void record_movie_frame(mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its record code */
 	if (movie_file != NULL && bitmap != NULL)
 	{
 		profiler_mark(PROFILER_MOVIE_REC);
 
 		if (movie_frame++ == 0)
 			save_frame_with(movie_file, bitmap, mng_capture_start);
 		save_frame_with(movie_file, bitmap, mng_capture_frame);
 
 		profiler_mark(PROFILER_END);
 	}
+#endif
 }
 
 
 
 /***************************************************************************
diff -U 5 --new-file --recursive src.ori/x86drc.c src/x86drc.c
--- src.ori/x86drc.c	2006-05-10 21:35:28.000000000 +0200
+++ src/x86drc.c	2006-06-16 18:45:12.000000000 +0200
@@ -674,10 +674,11 @@
 
 
 /*------------------------------------------------------------------
     drc_x86_get_features()
 ------------------------------------------------------------------*/
+#if 0
 UINT32 drc_x86_get_features(void)
 {
 	UINT32 features = 0;
 #ifdef _MSC_VER
 	__asm
@@ -705,10 +706,11 @@
 	: "%ecx", "%edx"	/* clobbers ebx, ecx and edx */
 	);
 #endif /* MSC_VER */
 	return features;
 }
+#endif
 
 
 
 /*------------------------------------------------------------------
     log_dispatch
